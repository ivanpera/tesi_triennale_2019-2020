\documentclass[a4paper, 12pt]{scrartcl}
\usepackage{geometry}
\usepackage{setspace}
\geometry{
  textheight = 40\baselineskip,
  outer = 20mm,
  inner = 20mm
}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{underscore}
\usepackage{float}
\usepackage{hyperref}

\graphicspath{ {./} }
\setstretch{1.2}
\setlength{\parindent}{0em}

\begin{document}
    
    % \hyphenation{OpenMP MPI thread for next}
    
    \section*{Introduzione}
    Gli ultimi anni hanno visto una maturazione dello standard[1 -> link a standard] GraphQL, dei servizi costruiti per implementarlo e la sua adozione da parte di numerose aziende. [2 -> https://graphql.org/users/] \\
    Definito per la prima volta internamente a Facebook nel 2012, oggi si presenta come uno standard capace di competere con l'architettura di tipo REST per il dialogo fra client e server. \\
    Caratterista fondamentale di GraphQL è lo schema che definisce le possibili operazioni di lettura, scrittura o modifica di entità che il client può eseguire in maniera personalizzata e mirata. \\
    Le entità sono definite da campi tipizzati e relazioni con altre entità, la struttura del dominio delle interrogazioni gestibili dal server è strutturata come un grafo. \\

    Le possibilità offerte dallo standard però non si limitano alla comunicazione fra client e server: essendo i campi delle entità tipizzati, ed avendo lo standard un concetto di reflection, è possibile usare 
    schemi GraphQL anche per definire lo strato del model. \\
    Questa possibilità rende quindi l'impiego di questo standard potenzialmente adatto per lo sviluppo Model Driven, potendo generare in modo automatizzato il codice applicativo che si occuperà di interfacciarsi con le strutture dallo schema GraphQL. \\

    Sfruttare quest'ultima prospettiva è ciò a cui mira l'attività descritta in questo documento: Twinlogix, azienda del Riminese, ha infatti da un po' di tempo iniziato a sfruttare le potenzialità del linguaggio di GraphQL per scrivere dei nuovi generatori
    di codice per automatizzare la creazione di parti di software adibite alla gestione delle comunicazioni con database. \\
    In particolare, il lavoro qui discusso consiste nello studio di una serie di tecnologie, librerie e del prototipo di generatore e DAO sviluppato dall'azienda per database MongoDB, per poi scrivere una versione base che possa gestire l'interazione con database SQL. \\
    \newpage

  \section*{Background}
    \subsection*{GraphQL}
      Ideato da Facebook nel 2012, il linguaggio GraphQL è stato successivamente (nel ?) pubblicato in maniera open source e, dal 2018, è gestito dalla Linux Foundation (moar) come standard.\\
      Nasce con il duplice scopo di modellare entità collegate fra di loro da relazioni e di fornire una soluzione a noti problemi dell'approccio RESTful, architettura per la comunicazione client server prevalente nello sviluppo in ambito web.\\
      Il linguaggio di GraphQL permette di definire uno schema costituito da un punto di ingresso, il nodo root, e uno o più tipi.\\
      
      Questi tipi possono rappresentare: (elenco puntato più espanso) tipi di dato, con i loro rispettivi campi, "richieste", "mutazioni", enum etc\dots\\
      
      Ogni tipo al suo interno piò contenere uno o più scalari, ovvero valori foglie, e uno o più altri oggetti complessi: in questo modo vengono definite le relazioni fra le varie entità.\\

      Quando un client contatta un server GraphQL, può fornire come parametri di richiesta operazioni di query o mutazione definita nello schema definenendo, specificandone i vari campi, quale forma avrà il risultato restituito dall'operazione.\\

      Le immagini successive mostrano un esempio di comunicazione con un server GraphQL in contrasto ad uno con uno utilizzante l'API REST
      https://www.howtographql.com/basics/1-graphql-is-the-better-rest/\\


      Si nota quindi che l'utilizzo di GraphQL permette di risolvere due grandi problemi dell'approccio REST:
      \begin{itemize}
        \item 
        Overfetching underfetching "This happens because the only way for a client to download data is by hitting endpoints that return fixed data structures"
        \item
        Inoltre, essendo specificato solo un punto d'ingresso nello schema (il nodo root), questo diventa anche l'unico endpoint che un clint dovrà contattare, evitando di dover inviare più richieste per accedere a dati associati. 
      \end{itemize}
      
      Necessità di modifcare backend in caso di cambiamenti a frontend -> da espandere \\
      Il fatto che lo schema indichi campi tipizzati rende pure molto più semplice la comprensione delle risposte da parte del server. -> spiega \\

      Essendo uno standard, GraphQL non è legato ad implementazioni o tecnologie. Lavorando in ambito NodeJS, in questo elaborato verrrà utilizzato Apollo Server[link].

      GraphQL comprende il concetto di reflection! (espandi)

    \subsection*{Model Driven Programming}
      Lo sviluppo "Model Driven" è un'approccio all'ingegneria del software orientato alla definizione di modelli piuttosto che di software.\\
      Parlare di modelli permette di astrarre la complessità del software, rendendo più chiara la visione dell'interazione fra le varie componenti dell'applicazione.\\
      L'approccio Model Driven è particolarmente efficace quando i suddetti modelli descrivono strutture che si prestano alla generazione automatizzata di codice: così facendo si permette di produrre applicazioni in modo molto più rapido, limitandosi a personalizzare
      i modelli per poi farli generare.\\
      Questo approccio aiuta anche a prevenire l'errore umano: spesso infatti le componenti modellabili e generabili automaticamente presentano strutture complesse, lunghe e difficili da scrivere e gestire personalmente dai programmatori.\\
      Il processo di scrittura, ma anche di aggiornamento, viene quindi privato di errori accidentali, difficili da localizzare, spostando tutta la complessità sui software di generazione del codice.\\

      GraphQL può essere usato come linguaggio per definire modelli: sono infatti già disponibili servizi di generazione di codice basata su schemi GraphQL.\\
      Quello utilizzato in questo caso è "GraphQL-code-generator" [link].
      \newpage

  \section*{Tecnologie}
    \subsection*{Graphql code generator}
      GraphQL code generator è un tool CLI open source, rilasciato nel XXXX da YYYY, in grado di analizzare uno schema GraphQL e, tramite plugins, generare codice.\\
      Il modo in cui questo strumento opera è utilizzando il pattern di programmazione "visitor".
      \subsubsection*{Pattern Visitor}
        Il pattern visitor è una soluzione al problema che si verifica quando bisogna effettuare operazioni su una struttura di oggetti senza però aggiungere funzionalità agli stessi:\\
        ogni oggetto della struttura implementa un'interfaccia che definisce un metodo "accept" che riceve come parametro un'implementazione dell'interfaccia Visitor.\\
        L'interfaccia Visitor specifica invece un metodo "visit" per ogni tipologia (ad esempio, ogni classe) di oggetto sul quale svolgere operazioni.\\
        Nell'applicazione principale poi, per ogni oggetto, viene chiamato il metodo accept passando ogni implementazione di Visitor, cosicchè per aggiungere operazioni/trasformazioni delle classi è possibile semplicemente implementare un nuovo Visitor.\\

        È questo il meccanismo alla base di GraphQL code generator: il programma naviga lo schema GraphQL e, ogni volta che individua tipi, interfacce, enum etc... chiama il metodo di gestione appropriato per ogni plugin (che svolge il compito di Visitor) indicato nel file di configurazione.\\

        Sono disponibili dei plugin predefiniti, fra cui quello, usato durante questo progetto, per generare tipi, interfacce etc... in linguaggio TypeScript.\\

    \subsection*{TypeScript}
    [parla dei tipi avanzati]

    \subsection*{Sequelize}
    TODO
  \newpage
  \section*{Requisiti}
    TODO

  \newpage
  \section*{Testing}
    TODO

  \newpage  
  \section*{Architettura del prototipo}
      L'interazione con lo strato del database è gestita tramite il pattern di programmazione Data Access Object (DAO).\\
      Il pattern DAO è una strategia impiegata per separare lo strato funzionale di un'applicazione da quello di persistenza dei dati: permette quindi di sviluppare il lato applicativo senza avere conoscenza di come i dati vengano effettivamente gestiti, così come poter modificare la gestione dei dati
      senza dover effettuare modifiche al lato applicativo, a patto che le interfacce rimangano inalterate.\\
      Il pattern prevede la definizione di un'interfaccia di alto livello che definisce i metodi di lettura e scrittura su un particolare tipo di oggetto, l'implementazione di questa e dell'oggetto, detto "Data Transfer Object", che non è altro che un'entità sulla quale mappare i dati custoditi nel DataBase.\\
      
      [immagini]\\

      Dovendo però scrivere dei dao per oggetti che verranno generati in futuro, l'implementazione aziendale del pattern punta a definire un generico DAO adatto a qualsiasi tipo di DTO, con metodi quindi non personalizzati in base ad esso.\\
      La struttura del dao è quindi composta da una serie di interfacce che definiscono dao di scrittura e lettura generici (di un generico tipo DTO) con operazioni che prendono come parametri filtri e opzioni che verranno poi generati dal generatore in base al tipo del DTO.\\
      
      [immagini]\\
      
      Viene anche definito un meccanismo di associazioni tra dao indipendente dal database sottostante, così da poter implementare associazioni fra i vari tipi dello schema graphql.\\

      [esempio + immagine di associazione in uno schema?]\\

      Infine, è definito un DAO astratto che implementa le operazioni descritte nelle interfacce tramite metodi template.\\
      La comunicazione con lo strato di persistenza è delegata a implementazioni della classe DAO astratta.\\
      TODO: sezione da espandere
    
      

      %     \begin{figure}[H]
      %         \includegraphics[width=\textwidth]{architecture}
      %         \caption{fonte: \href{https://www.splessons.com/lesson/angular-2-architecture/}{www.splessons.com}}
      %     \end{figure}
      %     I componenti possono poi usufruire di \emph{servizi}: script che, nella forma standard (quella rilevante in questo contesto), sono trattati come singleton dalla durata di vita pari a quella della sessione di utilizzo dell'applicazione.

      %         \item \hypertarget{Servizi}{Servizi}: molti servizi, soprattutto quelli che devono reperire informazioni interrogando un server esterno, erano stati scritti non separando la logica di richiesta dati

      %     Il problema dei servizi citato \hyperlink{Servizi}{sopra} è stato generalmente affrontato rendendoli dei semplici metodi getter poi con un parametro solo e opzionale, costituito da un'interfaccia dedicata a definire l'entità "richiesta".

      %     \begin{figure}[H]
      %         \includegraphics[width=\textwidth]{Request-hierarchy.png}
      %         \caption{Specializzazione dell'interfaccia "Richiesta"}
      %     \end{figure}
  \newpage
  \section*{Sviluppo del DAO}
    Di accordo con l'azienda, la versione SQL è stata scritta sfruttando la libreria ORM "Sequelize" per l'interazione con la base di dati. (Perchè Sequelize e non typeORM?)
    
    \subsection*{ORM}
      L'Object Relational Mapping è una tecnica di programmazione creata per favorire l'interazione fra un'applicazione scritta con un approccio ad oggetti ed una base di dati di tipo relazionale, o comunque modellante tabelli tramite campi scalari semplici.\\
        Una libreria ORM, infatti, rende possibile mappare le tabelle a degli oggetti e viceversa, permettendo pertanto di poter operare con questi dentro l'applicazione anche quando si deve comunicare con un DB.\\

        [Esempi?
            -inserimento oggetti in un DB\\
            -fetch oggetti da un DB
        ]

        Gli immediati vantaggi di questo approccio sono il ridotto numero di linee di codice scritte, nonchè la semplicità nell'interazione con il DB.\\
        Un altro importante vantaggio, prendendo ad esempio il caso di Sequelize, è il fatto di poter astrarre più facilmente anche l'implementazione del DataBase utilizzato e rendere più veloce la connesione con questo.\\

        [
            Esempi di connessione\\
            Esempio di query tradotta in modo diverso fra un db e l'altro
        ]

        D'altro canto, utilizzare una libreria ORM ha anche numerosi svantaggi:
        \begin{itemize}
          \item E' una libreria complessa se la si vuole sfruttare a fondo
          \item Bisogna effettuare un setup
          \item Toglie del controllo al programmatore vista la grande astrazione che introduce
          \item Può produrre query subottimali
        \end{itemize}
        Questi svantaggi non sono però stati ritenuti abbastanza influenti da decidere di optare per una soluzione di più basso livello.\\
      \newpage
    \subsection*{Problematiche}
      Le problematiche maggiori della fase di implemetazione del DAO astratto sono scaturite dalle differenze fra database di tipo documentale (come MongoDB) e database SQL.\\
      Gli schemi GraphQL utilizzati dall'azienda per eseguire test, e che sono stati presi come punto di riferimento per lo sviluppo dell'implementazione, presentano alcuni tipi difficilmente convertibili in maniera triviale, questo perchè gli schemi GraphQL sono
      particolarmente adatti per definire modelli che si adattano bene a documenti.

      I database documentali non sono basati su tabelle rigidamente definite, ma contengono al loro interno documenti, oggetti codificati in diversi standard (XML, JSON, YAML...), non strutturati e conservati in una singola istanza, piuttosto che essere potenzialmente distribuiti in più tabelle.
      
      [immagini con esempi di entrambi i db e didascalie]

      Di seguito è mostrato un esempio di tipo dalla difficile mappatura:
      [schema Person]
      problemi da identificare:
      \begin{itemize}
        \item Al suo interno il tipo contiene un altro tipo: \emph{Address} (questi tipi non rappresentano tabelle sulle quali effettuare richieste direttamente, ma sono tipi innestati nei tipi delle tabelle)
        \item Al suo interno il tipo contiene una interfaccia: \emph{Dog}
        \item Al suo interno il tipo contiene degli array
      \end{itemize}

      Questi problemi, eccetto quello dele interfacce(?), sono non esistenti se alla base è usato un database documentale: i documenti possono infatti possedere campi di tipi composti e array nativamente. 
      Il problema delle interfacce non verrà affrontato in questo documento.(?)
      \newpage
    \subsection*{Risoluzione delle problematiche - alto livello}
      In un primo momento era stato ipotizzato di gestire i campi di tipi composti e gli array con delle associazioni, sfruttando il meccanismo di riferimenti già presente nel progetto dell'azienda (-> da descrivere prima).\\
      Questo approccio avrebbe però portato a dover gestire una serie di complicazioni:
        \begin{itemize}
          \item Generazione manuale delle tabelle fittizie per gestire gli array di primitive
          \item Generazione manuale delle tabelle di giunzione per gestire le relazioni fra tipi
          \item Necessità di effettuare modifiche all'interfaccia delle associazioni, quindi dover modificare il dao comune
          \item Dipendenza di associazioni l'una dall'altra -> la cosa più grave *da discutere*
          \item gestire manualmente aggiornamento, eliminazione, sostituzione etc... di un entità con altri tipi innestati
        \end{itemize}
      
      Pertanto, sono stati invece evitati alcuni fra questi problemi usando le associazioni di Sequelize.\\
      (nota: riferimenti = associazioni indicate su schema GraphQL
              associazioni = associazioni Sequelize
      )\\
      Non usando il meccanismo di gestione delle associazioni si evita di dover effettuare cambiamenti all'interfaccia comune e non bisogna gestire dipendenze fra associazioni in quanto la risoluzione delle references dello schema verrà infatti eseguita solo dopo che Sequelize avrà raccolto tutti i dati della tabella e di quelle associate.\\
      Oltre a questo, Sequelize gestisce in autonomia (o dietro configurazione esplicita) la creazione di foreign keys per collegare le tabelle fra di loro, non rendendo necessario aggiungere questi campi, utili solo alla versione SQL, nello schema GraphQL.\\

      Il tipo precedentemente mostrato verrà quindi mappato con la seguente struttura di tabelle (viene ignorato il campo di tipo interfaccia) (Evidenzia campi autogenerati?)\\
      
      [immagini varie]\\
      \newpage
    \subsection*{Risoluzione delle problematiche - implementazione}

      Le funzioni principali del dao astratto da implementare sono:
      \begin{itemize}
        \item insert - inserimento
        \item update - aggiornamento
        \item delete - eliminazione
        \item find - ricerca
      \end{itemize}
      Tutte le altre operazioni sono derivabili da queste.\\
      Sequelize permetterebbe in molte di queste operazioni di effettuare automaticamente un join fra il Model iniziale, tutti quelli associati e, potenzialmente, anche quelli associati a quelli assocciati.\\
      Questo semplificherebbe di molto il problema della gestione dei modelli associati, permettendo di operare automaticamente sugli attributi innestati.\\
      Per ridurre il numero di operazioni di JOIN però, l'implementazione delle funzioni precedentemente elencate cercherà di includere solo le tabelle strettamente necessarie.\\

      [esempi?]\\

      È stato aggiunto al DAO astratto della versione sequelize un array di "SequelizeAssociations", un'interfaccia contenente informazioni sulle associazioni di Sequelize definite sul modello dello specifico DAO.\\
      \begin{verbatim}
        export interface SequelizeAssociation {
          field : string,
          type : DAOAssociationType,
          reference : DAOAssociationReference,
          foreignKey? : string,
          extractField? : string,
          sequelizeModelName : string,
          daoModelName : string
        }  
      \end{verbatim}
      
      [Descrizione campi interfaccia]

      Per riferimenti più rapidi, ogni dao contiene anche una mappa <nomeCampo : dao> chiamata \emph{associationsToDAO}, così da poter rilevare più velocemente campi legati a sequelizeAssociations.\\
      Per gestire le associazioni, molti dei metodi scritti hanno una struttura ricorsiva del tipo:
      \begin{verbatim}
        function recursiveFunction(..., dao : AbstractSequelizeDAO<...>) {
            if(dao.associationsToDAO[k]) {
                const association = dao.sequelizeAssociations
                                       .find(a => a.field === k);
                ...
                recursiveFunction(..., dao.associationsToDAO[k])
            }
        }
        
      \end{verbatim}

      \subsection*{Inserimento}
          [signature?]
          
          Sequelize permette di effettuare l'operazione di inserimento passando direttamente un oggetto composto, a patto di includere le associazioni alle tabelle relative
          nel parametro "options" di input.
          \begin{verbatim}
            return Product.create({
                title: 'Chair',
                user: {
                    firstName: 'Mick',
                    addresses: [{
                        city: 'Austin',
                        state: 'TX',
                        zip: '78704'
                    },{
                        city: 'Austin_2',
                        state: 'TX',
                        zip: '78704'
                    }]
                }
                }, {
                include: [{
                    association: Product.User,
                    include: [ User.Addresses ]
                }]
            });
          \end{verbatim}
          Esempio di inserimento di un Product, uno user associato e indirizzi associati allo user.

          L'inserimento pertanto viene eseguito prima processando tutti i campi con un'associazione con campo extractField, poi recuperando in modo ricorsivo le associazioni dall'oggetto passato in input.

      \subsection*{Aggiornamento}
          [signature?]

          L'operazione di aggiornamento con modelli associati non è correntemente supportata da Sequelize, quindi è stato implementato il seguente procedimento:\\
              -Eseguire un'operazione di ricerca richiedendo tutti i modelli da modificare in base al filtro passato alla funzione\\
              -per ogni campo dell'oggetto che indica i cambiamenti, controllare se il nome di questo campo corrisponde a quello di un'associazione\\
              -in caso positivo, per ogni modello da aggiornare, controllare se il campo di quel modello è un array\\
                  -nel caso lo sia, l'array va sostituito completamente con quello passato in ingresso. Vengono quindi cancellati tutti i modelli associati con il modello preso in esame e,
                  successivamente, si inseriscono nuovi modelli sulla base dei cambiamenti passati.\\
                  -altrimenti, se il campo non è vuoto, la funzione di aggiornamento viene richiamata ricorsivamente passando come parametri i cambiamenti sul campo corrente, il dao della tabella legata a quel campo e il modello da aggiornare\\
              -Alla fine, mappare tutti i modelli da aggiornare ai loro id, per poi eseguire un'unica operazione di aggiornamento in blocco sulla tabella.\\
          
          [magari uno schema?]


  \section*{Conclusioni}

  \section*{Bibliografia}
          \href{https://hostname.com}{placeholder} \\
\end{document}