Sommario

% Studiare il ruolo che la tecnologia GraphQL può avere nella metodologia di sviluppo Model-Driven (Model-First).
% Analizzare un prototipo sviluppato con questa tecnologia e realizzare un generatore di codice, basato su graphql-code-generator per i principali ORM su tecnologia NodeJS.

% Inizia con il parlare di model driven programming -> https://www.researchgate.net/publication/221249899_Model-Driven_Development_Its_Essence_and_Opportunities
% -> https://amslaurea.unibo.it/20886/1/tesi.pdf

Gli ultimi anni hanno visto una maturazione dello standard[1 -> link a standard] GraphQL, dei servizi costruiti per implementarlo e la sua adozione da parte di numerose aziende. [2 -> https://graphql.org/users/]
Definito per la prima volta internamente a Facebook nel 2012, oggi si presenta come uno standard capace di competere con l'architettura di tipo REST per il dialogo fra client e server.
Caratterista fondamentale di GraphQL è lo schema che definisce le possibili operazioni di lettura, scrittura o modifica di entità che il client può eseguire in maniera personalizzata e mirata.
Le entità sono definite da campi tipizzati e relazioni con altre entità, la struttura del dominio delle interrogazioni gestibili dal server è strutturata come un grafo.
% //NO: Grazie a questo schema, i client possono effettuare interrogazioni mirate, evitando di usare numerose chiamate ai server e di incorrere in problemi di under o over-fetching, come nel caso di soluzioni RESTful.

Le possibilità offerte dallo standard però non si limitano alla comunicazione fra client e server: essendo i campi delle entità tipizzati, ed avendo lo standard un concetto di reflection, è possibile usare 
schemi GraphQL anche per definire lo strato del model.
Questa possibilità rende quindi l'impiego di questo standard potenzialmente adatto per lo sviluppo Model Driven, potendo generare in modo automatizzato il codice applicativo che si occuperà di interfacciarsi con le strutture dallo schema GraphQL.

Sfruttare quest'ultima prospettiva è ciò a cui mira l'attività descritta in questo documento: Twinlogix, azienda del Riminese, ha infatti da un po' di tempo iniziato a sfruttare le potenzialità del linguaggio di GraphQL per scrivere dei nuovi generatori
di codice per automatizzare la creazione di parti di software adibite alla gestione delle comunicazioni con database.
In particolare, il lavoro qui discusso consiste nello studio di una serie di tecnologie, librerie e del prototipo di generatore sviluppato dall'azienda per database MongoDB, per poi scrivere una versione base che possa gestire l'interazione con database SQL.


Introduzione

    GraphQL
        Ideato da Facebook nel 2012, il linguaggio GraphQL è stato successivamente (nel ?) pubblicato in maniera open source e, dal 2018, è gestito dalla Linux Foundation (moar) come standard.
        Nasce con il duplice scopo di modellare entità collegate fra di loro da relazioni e di fornire una soluzione a noti problemi dell'approccio RESTful, architettura per la comunicazione client server prevalente nello sviluppo in ambito web.
        Il linguaggio di GraphQL permette di definire uno schema costituito da un punto di ingresso, il nodo root, e uno o più tipi.
        
        Questi tipi possono rappresentare: (elenco puntato più espanso) tipi di dato, con i loro rispettivi campi, "richieste", "mutazioni", enum etc..,  //operazioni di lettura e scrittura che il server mette a disposizione.
            /Immagine
        
        Ogni tipo al suo interno piò contenere uno o più scalari, ovvero valori foglie, e uno o più altri oggetti complessi: in questo modo vengono definite le relazioni fra le varie entità.

        Quando un client contatta un server GraphQL, può fornire come parametri di richiesta operazioni di query o mutazione definita nello schema definenendo, specificandone i vari campi, quale forma avrà il risultato restituito dall'operazione.

        Le immagini successive mostrano un esempio di comunicazione con un server GraphQL in contrasto ad uno con uno utilizzante l'API REST
        https://www.howtographql.com/basics/1-graphql-is-the-better-rest/


        Si nota quindi che l'utilizzo di GraphQL permette di risolvere due grandi problemi dell'approccio REST:
            -Overfetching underfetching "This happens because the only way for a client to download data is by hitting endpoints that return fixed data structures"
            -Inoltre, essendo specificato solo un punto d'ingresso nello schema (il nodo root), questo diventa anche l'unico endpoint che un clint dovrà contattare, evitando di dover inviare più richieste per accedere a dati associati. 
        
        Necessità di modifcare backend in caso di cambiamenti a frontend
        Il fatto che lo schema indichi campi tipizzati rende pure molto più semplice la comprensione delle risposte da parte del server.

        Essendo uno standard, GraphQL non è legato ad implementazioni o tecnologie. Lavorando in ambito NodeJS, in questo elaborato verrrà utilizzato Apollo Server[link].

        GraphQL comprende il concetto di reflection! (espandi)


    
    MDD
        Lo sviluppo "Model Driven" è un'approccio all'ingegneria del software orientato alla definizione di modelli piuttosto che di software.
        Parlare di modelli permette di astrarre la complessità del software, rendendo più chiara la visione dell'interazione fra le varie componenti dell'applicazione.
        L'approccio Model Driven è particolarmente efficace quando i suddetti modelli descrivono strutture che si prestano alla generazione automatizzata di codice: così facendo si permette di produrre applicazioni in modo molto più rapido, limitandosi a personalizzare
        i modelli per poi farli generare.
        Questo approccio aiuta anche a prevenire l'errore umano: spesso infatti le componenti modellabili e generabili automaticamente presentano strutture complesse, lunghe e difficili da scrivere e gestire personalmente dai programmatori.
        Il processo di scrittura, ma anche di aggiornamento, viene quindi privato di errori accidentali, difficili da localizzare, spostando tutta la complessità sui software di generazione del codice.

        GraphQL può essere usato come linguaggio per definire modelli: sono infatti già disponibili servizi di generazione di codice basata su schemi GraphQL.
        Quello utilizzato in questo caso è "GraphQL-code-generator" [link].


    Graphql code generator
        GraphQL code generator è un tool CLI open source, rilasciato nel XXXX da YYYY, in grado di analizzare uno schema GraphQL e, tramite plugins, generare codice.
        Il modo in cui questo strumento opera è utilizzando il pattern di programmazione "visitor".
        Il pattern visitor è una soluzione al problema che si verifica quando bisogna effettuare operazioni su una struttura di oggetti senza però aggiungere funzionalità agli stessi:
        ogni oggetto della struttura implementa un'interfaccia che definisce un metodo "accept" che riceve come parametro un'implementazione dell'interfaccia Visitor.
        L'interfaccia Visitor specifica invece un metodo "visit" per ogni tipologia (ad esempio, ogni classe) di oggetto sul quale svolgere operazioni.
        Nell'applicazione principale poi, per ogni oggetto, viene chiamato il metodo accept passando ogni implementazione di Visitor, cosicchè per aggiungere operazioni/trasformazioni delle classi è possibile semplicemente implementare un nuovo Visitor.
        È questo il meccanismo alla base di GraphQL code generator: il programma naviga lo schema GraphQL e, ogni volta che individua tipi, interfacce, enum etc... chiama il metodo di gestione appropriato per ogni plugin (che svolge il compito di Visitor) indicato nel file di configurazione.
        Sono disponibili dei plugin predefiniti, fra cui quello, usato durante questo progetto, per generare tipi, interfacce etc... in linguaggio TypeScript.
        La parte di elaborato dedicata alla scrittura del generatore di codice consisterà dunque nell'impletare un plugin personalizzato compatibile con GraphQl code generator.
        I lavori saranno svolti sulla base di un plugin scritto internamente all'azienda, dedicato alla generazione di schemi e metodi per eseguire operazioni su un database MongoDB.
        Il codice generato dai plugin aziendali sarà basato su una struttura astratta aderente al pattern Data Access Object (DAO).

    DAO Pattern
        Il pattern DAO è una strategia impiegata per separare lo strato funzionale di un'applicazione da quello di persistenza dei dati: permette quindi di sviluppare il lato applicativo senza avere conoscenza di come i dati vengano effettivamente gestiti, così come poter modificare la gestione dei dati
        senza dover effettuare modifiche al lato applicativo, a patto che le interfacce rimangano inalterate.
        Il pattern prevede la definizione di un'interfaccia di alto livello che definisce i metodi di lettura e scrittura su un particolare tipo di oggetto, l'implementazione di questa e dell'oggetto, detto "Data Transfer Object", che non è altro che un'entità sulla quale mappare i dati custoditi nel DataBase.
        
        [immagini]

        Dovendo però scrivere dei dao per oggetti che verranno generati in futuro, l'implementazione aziendale del pattern punta a definire un generico DAO adatto a qualsiasi tipo di DTO, con metodi quindi non personalizzati in base ad esso.
        La struttura del dao è quindi composta da una serie di interfacce che definiscono dao di scrittura e lettura generici (di un generico tipo DTO) con operazioni che prendono come parametri filtri e opzioni che verranno poi generati dal generatore in base al tipo del DTO.
        [Immagini?]
        
        Viene anche definito un meccanismo di associazioni tra dao indipendente dal database sottostante, così da poter implementare associazioni fra i vari tipi dello schema graphql.

        [esempio + immagine di associazione in uno schema?]

        Infine, è definito un DAO astratto che implementa le operazioni descritte nelle interfacce tramite metodi template.
        La comunicazione con lo strato di persistenza è delegata a implementazioni della classe DAO astratta.

        Come scritto in precedenza, l'azienda aveva già scritto un prototipo di implementazione per comunicazione con dabase MongoDB, pertanto i lavori di scrittura di una versione capace di interfacciarsi con database SQL sono partiti studiando questa.
        Di accordo con l'azienda, la versione SQL è stata scritta sfruttando la libreria ORM "Sequelize" per l'interazione con la base di dati.
    
    ORM
        L'Object Relational Mapping è una tecnica di programmazione creata per favorire l'interazione fra un'applicazione scritta con un approccio ad oggetti ed una base di dati di tipo relazionale, o comunque modellante tabelli tramite campi scalari semplici.
        Una libreria ORM, infatti, rende possibile mappare le tabelle a degli oggetti e viceversa, permettendo pertanto di poter operare con questi dentro l'applicazione anche quando si deve comunicare con un DB.
        [Esempi?
            -inserimento oggetti in un DB
            -fetch oggetti da un DB
        ]

        Gli immediati vantaggi di questo approccio sono il ridotto numero di linee di codice scritte, nonchè la semplicità nell'interazione con il DB.
        Un altro importante vantaggio, prendendo ad esempio il caso di Sequelize, è il fatto di poter astrarre più facilmente anche l'implementazione del DataBase utilizzato e rendere più veloce la connesione con questo.
        [
            Esempi di connessione
            Esempio di query tradotta in modo diverso fra un db e l'altro
        ]

        D'altro canto, utilizzare una libreria ORM ha anche numerosi svantaggi:
            - E' una libreria complessa se la si vuole sfruttare a fondo
            - Bisogna effettuare un setup
            - Toglie del controllo al programmatore vista la grande astrazione che introduce
            - Può produrre query subottimali

        Questi svantaggi non sono però stati ritenuti abbastanza influenti da decidere di optare per una soluzione di più basso livello.
        Verranno qui di seguito illustrati i meccanismi principali della libreria Sequelize.
        Sequelize
        modelli
        associazioni
    
    Analisi del prototipo
        -descrizione prototipo DAO

    Obiettivi/Requisiti attività ?

    Problematiche del progetto
        Le problematiche maggiori della fase di implemetazione del DAO astratto sono scaturite dalle differenze fra database di tipo documentale (come MongoDB) e database SQL.
        Gli schemi GraphQL utilizzati dall'azienda per eseguire test, e che sono stati presi come punto di riferimento per lo sviluppo dell'implementazione, presentano alcuni tipi difficilmente convertibili in maniera triviale, questo perchè gli schemi GraphQL sono
        particolarmente adatti per definire modelli che si adattano bene a documenti.

        I database documentali non sono basati su tabelle rigidamente definite, ma contengono al loro interno documenti, oggetti codificati in diversi standard (XML, JSON, YAML...), non strutturati e conservati in una singola istanza, piuttosto che essere potenzialmente distribuiti in più tabelle.
        
        [immagini con esempi di entrambi i db e didascalie]

        Di seguito è mostrato un esempio di tipo dalla difficile mappatura:
        [schema Person]
        problemi da identificare:
            -Al suo interno il tipo contiene un altro tipo: Address (questi tipi non rappresentano tabelle sulle quali effettuare richieste direttamente, ma sono tipi innestati nei tipi delle tabelle)
            -Al suo interno il tipo contiene una interfaccia: Dog
            -Al suo interno il tipo contiene degli array

        Questi problemi, eccetto quello dele interfaccie, sono non esistenti se alla base è usato un database documentale: i documenti possono infatti possedere campi di tipi composti e array nativamente. 
        Il problema delle interfacce non verrà affrontato in questo documento.(?)

    Approccio alla risoluzione delle problematiche (alto livello)
        In un primo momento era stato ipotizzato di gestire i campi di tipi composti e gli array con delle associazioni, sfruttando il meccanismo di riferimenti già presente nel progetto dell'azienda (-> da descrivere prima).
        Questo approccio avrebbe però portato a dover gestire una serie di complicazioni:
            -Generazione manuale delle tabelle fittizie per gestire gli array di primitive
            -Generazione manuale delle tabelle di giunzione per gestire le relazioni fra tipi
            -Necessità di effettuare modifiche all'interfaccia delle associazioni, quindi dover modificare il dao comune
            -Dipendenza di associazioni l'una dall'altra -> la cosa più grave *da discutere*
            -gestire manualmente aggiornamento, eliminazione, sostituzione etc... di un entità con altri tipi innestati
            -altro...?
        
        Pertanto, sono stati invece evitati alcuni fra questi problemi usando le associazioni di Sequelize.
        (nota: riferimenti = associazioni indicate su schema GraphQL
               associazioni = associazioni Sequelize
        )
        Non usando il meccanismo di gestione delle associazioni si evita di dover effettuare cambiamenti all'interfaccia comune e non bisogna gestire dipendenze fra associazioni in quanto la risoluzione delle references dello schema verrà infatti eseguita solo dopo che Sequelize avrà raccolto tutti i dati della tabella e di quelle associate.
        Oltre a questo, Sequelize gestisce in autonomia (o dietro configurazione esplicita) la creazione di foreign keys per collegare le tabelle fra di loro.

        Il tipo precedentemente mostrato verrà quindi mappato con la seguente struttura di tabelle (viene ignorato il campo di tipo interfaccia)
        [immagini varie]

    Approccio alla risoluzione delle problematiche (livello implementativo)
        Le funzioni principali del dao astratto da implementare sono:
            -insert
            -update
            -delete
            -find
        Tutte le altre operazioni sono derivabili da queste.
        Sequelize permetterebbe in molte di queste operazioni di effettuare automaticamente un join fra il Model iniziale, tutti quelli associati e, potenzialmente, anche quelli associati a quelli assocciati.
        Questo semplificherebbe di molto il problema della gestione dei modelli associati, permettendo di operare automaticamente sugli attributi innestati.
        Per ridurre il numero di operazioni di JOIN però, l'implementazione delle funzioni precedentemente elencate cercherà di includere solo le tabelle strettamente necessarie.
        [esempi?]

        È stato aggiunto al DAO astratto della versione sequelize un array di "SequelizeAssociations", un'interfaccia contenente informazioni sulle associazioni di Sequelize definite sul modello dello specifico DAO.
        ```
        export interface SequelizeAssociation {
            field : string,
            type : DAOAssociationType,
            reference : DAOAssociationReference,
            foreignKey? : string,
            extractField? : string,
            sequelizeModelName : string,
            daoModelName : string
        }
        ```

        Per riferimenti più rapidi, ogni dao contiene anche una mappa campo : dao chiamata "associationsToDAO", così da poter rilevare più velocemente campi legati a sequelizeAssociations.

        [Descrizione campi interfaccia]

        (A supporto dell'implementazione di questi metodi, è stato scritto un file aggiuntivo di parsing?)

        INSERT
            ```
            async _insert(record: ConditionalPartialBy<ModelType, IDKey, IDAutogenerated>, options?: WriteOptions): Promise<ModelType> {
                return (await this.dbToModels([await this.insertAndRetModel(record, options)]))[0];
            }
            ```
            [dbToModels magari lo avevi già discusso prima?]
            Il metodo dbToModels in questo caso riceve un array di Models e ne chiama il metodo "toJSON()" per convertirli in POJO.

            "insertAndRetModel" è un metodo che costruisce la query per il metodo statico del modello del DAO.
            ```
            private async insertAndRetModel(record: ConditionalPartialBy<ModelType, IDKey, IDAutogenerated>, options?: WriteOptions): Promise<Model> {
                const _record = this.modelToDb(record);
                const _options = {...options?._, ...{include : this.rGetInsertIncludes(_record, this)}};
                return await this.dbModel.create(_record, _options);
            }
            ```
            Il metdo modelToDb è un primo caso di funzione ricorsiva basata sulle assoiazioni Sequelize, tecnica che è stata applicata ripetutamete durante il progetto:

            ```
            private rModelToDb(model : {[key: string] : any}, dao : AbstractSequelizeDAO<any, any, any, any, any, any, any, any>) : any {
            for(let k in model) {
                if (dao.associationsToDAO[k]) {
                    const assoc = dao.sequelizeAssociations.find(a => a.field === k);
                    if(Array.isArray(model[k])) {
                        const newCollection = [];
                        for(let m of model[k]) {
                            if(typeof m === "object") {
                                this.rModelToDb(m, dao.associationsToDAO[k]);
                                newCollection.push(m)
                            } else if(assoc && assoc.extractField) {
                                newCollection.push({[assoc.extractField] : m})
                            }
                        }
                        model[k] = newCollection;
                    } else if (typeof model[k] === "object") {
                        model[k] = this.rModelToDb(model[k], dao.associationsToDAO[k]);
                    } else if (assoc?.extractField) {
                        model[k] = {[assoc.extractField] : model[k]}
                    }
                }
            }
            return model;
        }
            ```



    % Applicazione visitor pattern per generazione codice(?)


