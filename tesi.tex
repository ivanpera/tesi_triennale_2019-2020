Sommario

Studiare il ruolo che la tecnologia GraphQL può avere nella metodologia di sviluppo Model-Driven (Model-First).
Analizzare un prototipo sviluppato con questa tecnologia e realizzare un generatore di codice, basato su graphql-code-generator per i principali ORM su tecnologia NodeJS.

Inizia con il parlare di model driven programming -> https://www.researchgate.net/publication/221249899_Model-Driven_Development_Its_Essence_and_Opportunities
-> https://amslaurea.unibo.it/20886/1/tesi.pdf

Gli ultimi anni hanno visto una maturazione dello standard[1 -> link a standard] GraphQL, dei servizi costruiti per implementarlo e la sua adozione da parte di numerose aziende. [2 -> https://graphql.org/users/]
Definito per la prima volta internamente a Facebook nel 2012, oggi si presenta come uno standard capace di competere con l'architettura di tipo REST per il dialogo fra client e server.
Caratterista fondamentale di GraphQL è lo schema che definisce le possibili operazioni di lettura, scrittura o modifica di entità che il client può eseguire in maniera personalizzata e mirata.
Le entità sono definite da campi tipizzati e relazioni con altre entità, la struttura del dominio delle interrogazioni gestibili dal server è strutturata come un grafo.
//NO: Grazie a questo schema, i client possono effettuare interrogazioni mirate, evitando di usare numerose chiamate ai server e di incorrere in problemi di under o over-fetching, come nel caso di soluzioni RESTful.

Le possibilità offerte dallo standard però non si limitano alla comunicazione fra client e server: essendo i campi delle entità tipizzati, ed avendo lo standard un concetto di reflection, è possibile usare 
schemi GraphQL anche per definire lo strato del model.
Questa possibilità rende quindi l'impiego di questo standard potenzialmente adatto per lo sviluppo Model Driven, potendo generare in modo automatizzato il codice applicativo che si occuperà di interfacciarsi con le strutture dallo schema GraphQL.

Sfruttare quest'ultima prospettiva è ciò a cui mira l'attività descritta in questo documento: Twinlogix, azienda del Riminese, ha infatti da un po' di tempo iniziato a sfruttare le potenzialità del linguaggio di GraphQL per scrivere dei nuovi generatori
di codice per automatizzare la creazione di parti di software adibite alla gestione delle comunicazioni con database.
In particolare, il lavoro qui discusso consiste nello studio di una serie di tecnologie, librerie e del prototipo di generatore sviluppato dall'azienda per database MongoDB, per poi scrivere una versione base che possa gestire l'interazione con database SQL.


Introduzione

    GraphQL
        Ideato da Facebook nel 2012, il linguaggio GraphQL è stato successivamente (nel ?) pubblicato in maniera open source e, dal 2018, è gestito dalla Linux Foundation (moar) come standard.
        Nasce con il duplice scopo di modellare entità collegate fra di loro da relazioni e di fornire una soluzione a noti problemi dell'approccio RESTful, architettura per la comunicazione client server prevalente nello sviluppo in ambito web.
        Il linguaggio di GraphQL permette di definire uno schema costituito da un punto di ingresso, il nodo root, e uno o più tipi.
        
        Questi tipi possono rappresentare: (elenco puntato più espanso) tipi di dato, con i loro rispettivi campi, "richieste", "mutazioni", enum etc..,  //operazioni di lettura e scrittura che il server mette a disposizione.
            /Immagine
        
        Ogni tipo al suo interno piò contenere uno o più scalari, ovvero valori foglie, e uno o più altri oggetti complessi: in questo modo vengono definite le relazioni fra le varie entità.

        Quando un client contatta un server GraphQL, può fornire come parametri di richiesta operazioni di query o mutazione definita nello schema definenendo, specificandone i vari campi, quale forma avrà il risultato restituito dall'operazione.

        Le immagini successive mostrano un esempio di comunicazione con un server GraphQL in contrasto ad uno con uno utilizzante l'API REST
        https://www.howtographql.com/basics/1-graphql-is-the-better-rest/


        Si nota quindi che l'utilizzo di GraphQL permette di risolvere due grandi problemi dell'approccio REST:
            -Overfetching underfetching "This happens because the only way for a client to download data is by hitting endpoints that return fixed data structures"
            -Inoltre, essendo specificato solo un punto d'ingresso nello schema (il nodo root), questo diventa anche l'unico endpoint che un clint dovrà contattare, evitando di dover inviare più richieste per accedere a dati associati. 
        
        Necessità di modifcare backend in caso di cambiamenti a frontend
        Il fatto che lo schema indichi campi tipizzati rende pure molto più semplice la comprensione delle risposte da parte del server.

        Essendo uno standard, GraphQL non è legato ad implementazioni o tecnologie. Lavorando in ambito NodeJS, in questo elaborato verrrà utilizzato Apollo Server[link].

        GraphQL comprende il concetto di reflection! (espandi)


    
    MDD
        Lo sviluppo "Model Driven" è un'approccio all'ingegneria del software orientato alla definizione di modelli piuttosto che di software.
        Parlare di modelli permette di astrarre la complessità del software, rendendo più chiara la visione dell'interazione fra le varie componenti dell'applicazione.
        L'approccio Model Driven è particolarmente efficace quando i suddetti modelli descrivono strutture che si prestano alla generazione automatizzata di codice: così facendo si permette di produrre applicazioni in modo molto più rapido, limitandosi a personalizzare
        i modelli per poi farli generare.
        Questo approccio aiuta anche a prevenire l'errore umano: spesso infatti le componenti modellabili e generabili automaticamente presentano strutture complesse, lunghe e difficili da scrivere e gestire personalmente dai programmatori.
        Il processo di scrittura, ma anche di aggiornamento, viene quindi privato di errori accidentali, difficili da localizzare, spostando tutta la complessità sui software di generazione del codice.

        GraphQL può essere usato come linguaggio per definire modelli: sono infatti già disponibili servizi di generazione di codice basata su schemi GraphQL.
        Quello utilizzato in questo caso è "GraphQL-code-generator" [link].


    Graphql code generator
        GraphQL code generator è un tool CLI open source, rilasciato nel XXXX da YYYY, in grado di analizzare uno schema GraphQL e, tramite plugins, generare codice.
        Il modo in cui questo strumento opera è utilizzando il pattern di programmazione "visitor".
        Il pattern visitor è una soluzione al problema che si verifica quando bisogna effettuare operazioni su una struttura di oggetti senza però aggiungere funzionalità agli stessi:
        ogni oggetto della struttura implementa un'interfaccia che definisce un metodo "accept" che riceve come parametro un'implementazione dell'interfaccia Visitor.
        L'interfaccia Visitor specifica invece un metodo "visit" per ogni tipologia (ad esempio, ogni classe) di oggetto sul quale svolgere operazioni.
        Nell'applicazione principale poi, per ogni oggetto, viene chiamato il metodo accept passando ogni implementazione di Visitor, cosicchè per aggiungere operazioni/trasformazioni delle classi è possibile semplicemente implementare un nuovo Visitor.
        È questo il meccanismo alla base di GraphQL code generator: il programma naviga lo schema GraphQL e, ogni volta che individua tipi, interfacce, enum etc... chiama il metodo di gestione appropriato per ogni plugin (che svolge il compito di Visitor) indicato nel file di configurazione.
        Sono disponibili dei plugin predefiniti, fra cui quello, usato durante questo progetto, per generare tipi, interfacce etc... in linguaggio TypeScript.
        La parte di elaborato dedicata alla scrittura del generatore di codice consisterà dunque nell'impletare un plugin personalizzato compatibile con GraphQl code generator.
        I lavori saranno svolti sulla base di un plugin scritto internamente all'azienda, dedicato alla generazione di schemi e metodi per eseguire operazioni su un database MongoDB.
        Il codice generato dai plugin aziendali sarà basato su una struttura astratta aderente al pattern Data Access Object (DAO).

    DAO Pattern -> è generico, ma dipende da databases ()
        Il pattern DAO è una strategia impiegata per separare lo strato funzionale di un'applicazione da quello di persistenza dei dati: permette quindi di sviluppare il lato applicativo senza avere conoscenza di come i dati vengano effettivamente gestiti, così come poter modificare la gestione dei dati
        senza dover effettuare modifiche al lato applicativo, a patto che le interfacce rimangano inalterate.
        Il pattern prevede la definizione di un'interfaccia di alto livello che definisce i metodi di lettura e scrittura su un particolare tipo di oggetto, l'implementazione di questa e dell'oggetto, detto "Data Transfer Object", che non è altro che un'entità sulla quale mappare i dati custoditi nel DataBase.
        
        [immagini]

        Dovendo però scrivere dei dao per oggetti che verranno generati in futuro, l'implementazione aziendale del pattern punta a definire un generico DAO adatto a qualsiasi tipo di DTO, con metodi quindi non personalizzati in base ad esso.
        La struttura del dao è quindi composta da una serie di interfacce che definiscono dao di scrittura e lettura generici (di un generico tipo DTO) con operazioni che prendono come parametri filtri e opzioni che verranno poi generati dal generatore in base al tipo del DTO.
        [Immagini?]
        
        Viene anche definito un meccanismo di associazioni tra dao indipendente dal database sottostande, così da poter implementare associazioni fra i vari tipi dello schema graphql.

        [esempio + immagine di associazione in uno schema?]

        Infine, è definito un DAO astratto che implementa le operazioni descritte nelle interfacce tramite metodi template.
        La comunicazione con lo strato di persistenza è delegata a implementazioni della classe DAO astratta.

        Come scritto in precedenza, l'azienda aveva già scritto un prototipo di implementazione per comunicazione con dabase MongoDB; l'attività sul fronte di scrittura di un'implementazione del DAO quindi è consistita nella scrittura di una versione capace di interfacciarsi con database SQL, sfruttando la libreria ORM "Sequelize".

    
       
    ORM (Interazione con databases)
        Per interagire con DBs ci sono più opzioni (principalmente due: utilizzare direttamente il driver DB oppure un ORM? https://blog.logrocket.com/why-you-should-avoid-orms-with-examples-in-node-js-e0baab73fa5/#isormreallynecessary) 
        
        Sequelize
        modelli
        associazioni
        
    Risoluzione differenze fra db relazionali e documentali
    
    DB documentali vs Relazionali

    Applicazione visitor pattern per generazione codice(?)


